# 一、实验目的

**题目一：电话号码问题**

1. 理解等价类划分的概念；

2. 能够根据规格说明设计出符合等价类划分的测试用例；

3. 能够应用等价类划分测试法设计出有效的测试方案。

4. 能熟练应用黑盒测试技术进行测试用例设计；

5. 对测试用例进行优化设计；

**题目二：三角形问题**

1. 理解等价类划分的概念；

2. 能够根据规格说明设计出符合等价类划分的测试用例；

3. 能够应用等价类划分测试法设计出有效的测试方案。

4. 能熟练应用黑盒测试技术进行测试用例设计；

5. 对测试用例进行优化设计；

**题目三：日期问题**

1. 理解等价类划分的概念；

2. 能够根据规格说明设计出符合等价类划分的测试用例；

3. 能够应用等价类划分测试法设计出有效的测试方案

4. 能熟练应用黑盒测试技术进行测试用例设计；

5. 对测试用例进行优化设计

**题目四：找零钱最佳组合**

1. 理解等价类划分的概念；

2. 能够根据规格说明设计出符合等价类划分的测试用例；

3. 能够应用等价类划分测试法设计出有效的测试方案

4. 能熟练应用黑盒测试技术进行测试用例设计；

5. 对测试用例进行优化设计

# 二、实验原理
- 黑盒测试：称为功能测试或数据驱动测试。在测试时，把被测程序视为一个不能打开的黑盒子，在完全不考虑内部特性的情况下进行。
- 采用黑盒测试的目的主要是在己知软件产品所应具有的功能的基础上，进行：
	1. 检查程序功能能否按需求规格说明书的规定正常使思，测试各个功能是否有道漏，检测性能等特性要求是否满足。
	2. 检测人机交互是否错识，检测数据绪构或外部数据库访问是否销误，程序是否能适当地接收输入数据而产生正确的输出结果，并保持外部信息（如数据库或文件）的完整性。
	3. 检测程序初始化和终止方面的错识
- 常见的黑盒测试方法有等价类划分法、边界值法、因果图法、决策表法。

### 等价类测试
- 等价类划分法是一种重要 的、典型的黑盒测试方法，它将不能穷举的测试过程进行合理分类，从而保证设计出来的测试用例具有完整性和代表性。
- 等价类划分法是把所有可能的输入数据，即程序的输入域划分成若干互不相交的子集，称为等价类。
- 所有子集的并集则构成整个输入域。然后从每一个子集中选取少数有代表性的数据作为测试用例。

**等价类的划分有两种不同的情况：**

1. 有效等价类：是指对于程序的规格说明来说，是合理的，有意义的输入数据构成的集合。
2.  无效等价类： 是指对于程序的规格说明来说，是不合理的， 无意义的输入数据构成的集合。在设计测试用例时，要同时考虑有效等价类和无效等价类的设计。
**用等价类划分法设计测试用例步骤：**
1. 形成等价类表，每一等价类规定一个唯一的编号；
2. 设计一个新的测试用例，使其尽可能多地覆盖尚未覆盖的有效等价类，重复这一步骤，直到所有有效等价类均被测试用例所覆盖；
3. 设计一个新测试用例，使其只覆盖一个无效等价类，重复这一步骤直到所有无效等价类均被覆盖。

### 边界值测试
总述:边界值测试是一种测试方法，它专注于测试输入数据的边界值，例如输入的最小值、最大值和临界值。在该方法中，测试人员会针对各种边界条件设计测试用例，从而揭示程序在边界条件下的错误。
**标准边界值测试** 考虑数据范围内的边界值
- 使用在最小值(Min)、略高于最小值(Min+)、正常值(Normal)、略低于最大值(Max-)和最大值处(Max)取输入变量值。
**健壮边界值测试** 考虑有效和无效数据范围内的边界值
- 略低于最小值(Min-)最小值(Min)、略高于最小值(Min+)、正常值(Normal)、略低于最大值(Max-)和最大值处(Max)取输入变量值，略高于最大值(Max+)
### 基于决策表的测试
决策表适合描述不同条件集合下采取行动的若干组合的情况。使用决策表标识测试用例，则把条件解释为输入，行动解释为输出。有时条件最终引用输入的等价类，行为引用被测试软件的主要功能处理部分，规则解释为测试用例。
对于有限条目决策表，如果有 n 个条件， 则必须有 2 条规则。 如果不关心条目实际地表明条件是不相关的，则没有不关心条目的规则统计为 1 条规则， 规则中每出现一个不关心条目，该规则数乘一次 2。

# 三、实验步骤
### **题目一：电话号码问题**
某城市电话号码由三部分组成。它们的名称和内容分别是： 地区码：空白或三位数字；前 缀非'0'或'1'的三位数字；后 缀：4 位数字。假定被测程序能接受一切符合上述规定的电话号码，拒绝所有不符合规定的电话号码。根据该程序的规格说明，作等价类的划分，并设计测试方案。

- **被测程序：**
```
#include <iostream>
#include <regex>
#include <string>
using namespace std;
bool ValidatePhoneNumber(const string& phoneNumber) {
    regex re(R"(^(\d{3}[- ]?)?[2-9]{3}\d{4}$)");
    return regex_match(phoneNumber, re);
}

int main() {
    string phoneNumber;
    cout << "Enter a phone number: ";
    getline(cin, phoneNumber);

    if (ValidatePhoneNumber(phoneNumber)) {
        cout << "Valid phone number" << std::endl;
    }
    else {
        cout << "Invalid phone number" << std::endl;
    }

    return 0;
}

```

- **等价类划分**：

| 输入条件    | 有效等价类    | 编号    | 无效等价类   | 编号    |
|-------|-------|-------|-------|-------|
| 是否构成电话号码 | 地区码空白或三位数字 |1 | 地区码不空白且非三位数字 | 5|
|  | 前缀非'0'或'1'| 2|  前缀为'0'或'1' | 6 |
|  | 前缀为三位数 | 3 | 前缀不为三位数 | 7 |
|  | 后缀为4位数的电话号码 | 4 | 后缀不为4位数的电话号码 | 8 |

- **设计测试用例：**

| 输入| 预期结果 | 覆盖范围 |
|-------|-------|-------|
| 1234567890 | true | 1、2、3、4 |
| 123-4567890| true| 1、2、3、4|
| 456-7890 | true| 1、2、3、4|
| 12-34567890 | false|5 |
| 34567890|false |5 |
| 0345678 |false |4、6 |
| 123457890 |false |4、7 |
| 457890 | false| 4、7|
| 12345678 |flase |1、2、3、8 |
| 45678 |false | 2、3、8|


### 题目二：三角形问题
根据下面给出的规格说明，利用等价类划分的方法，给出足够的测试用例。
“一个程序读入三个整数。把此三个数值看成是一个三角形的三个边。这个程序要打印出信息，说明这个三角形是三边不等的、是等腰的、还是等边的。

* **被测程序**
```
#include<iostream>
using namespace std;
int main() {
	float a, b, c;
	cout << "分别输入三条线段的长度（用空格分隔）" << endl;
	cin >> a >> b >> c;
	if (cin.fail()) {
		cout << "非法输入，请重新输入" << endl;
		cin.clear();
		while (cin.get() != '\n');//清空输入流
	}else if (a < 0 || b < 0 || c < 0) {
		cout << "非法输入，请重新输入" << endl;
	}
	else {
		if (a + b <= c || a + c <= b || b + c <= a) {
			cout << "不能构成三角形" << endl;
		}
		else if ((a == b) && (b == c)) {
			cout << "构成等边三角形" << endl;
		}
		else if ((a * a + b * b == c * c) || (b * b + c * c == a * a) || (a * a + c * c == b * b))
			if ((a == b) || (b == c) || (c == a))
				cout << "构成等腰直角三角形" << endl;
			else cout << "构成直角三角形" << endl;
		else if (a == b || b == c || c == a) {
			cout << "等腰三角形" << endl;
		}
		else {
			cout << "构成普通三角形" << endl;
		}
	}
	
	return 0;
}
```

 - **等价类划分**
 
| 输入条件| 有效等价类 | 编号 |无效等价类|编号|
|-------   |-------    |-------|------  |-------|
|输入三个正整数|a>0          |1|       a<=0|    7|
||          b>0          |2|       b<=0|     8|
||          c>0|          3|       c<=0|    9|
|构成三角形|          a+b>c|          4|       a+b<=c|    10|
||          a+c>b|          5|       a+c<=b|    11|
||          b+c>a|          6|       b+c<=a|    12|
|构成等腰三角形|          a等于b|          13|     a!=b&&a!=c&&b!=c  |  16|
| |                       a等于c|          14|       ||
| |                       b等于c|          15|       ||
|构成等边三角形|a等于b&&b等于c&&a等于c|17|a!=b|20|
||             |                     |   b!=c|21||
||             |                     |   a!=c|22||

- **设计测试用例**

| 输入(a、b、c) | 预期结果 | 覆盖范围 | 
|-----|-----|-----| 
| 4、5、6        |其他三角形 | 1、2、3、4、5、6 |
| 5、5、6        |等腰三角形 | 1、2、3、4、5、6、13 |
| 5、6、5        |等腰三角形 | 1、2、3、4、5、6、14 |
| 6、5、5        |等腰三角形 | 1、2、3、4、5、6、15 |
| 6、6、6        |等腰三角形 | 1、2、3、4、5、6、13、14、15、17 |
| 1、5、6        |false | 2、3、10 |
| 1、6、5        |false | 2、3、11 |
| 6、1、5        |false | 2、3、12 |
| 1、2、5        |false | 2、3、20、21、22|

### 题目三：日期问题

用决策表测试法测试以下程序:该程序有三个输入变量 month、day、year（month 、day 和 year 均为整数值，并且满足： 1≤month≤12 和 1≤day≤31 分), 别作为输入日期的月份、日、年份，通过程序可以输出该输入日期在日历上隔一天的日期。例如，输入为 2004年 11 月 29 日,则该程序的输出为 2004 年 12 月 1 日。

- **被测程序**
```
#include<iostream>
using namespace std;

bool is_leap_year(int year) {
    return (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;
}

bool is_valid_date(int year, int month, int day) {
    if (month < 1 || month > 12) {
        return false;
    }

    bool is_leap_years = is_leap_year(year);

    switch (month) {
    case 2:
        if (is_leap_years) {
            return day >= 1 && day <= 29;
        }
        else {
            return day >= 1 && day <= 28;
        }
    case 4:
    case 6:
    case 9:
    case 11:
        return day >= 1 && day <= 30;
    default:
        return day >= 1 && day <= 31;
    }
}

void get_next_date(int year, int month, int day, int& next_year, int& next_month, int& next_day) {
    bool is_leap_years = is_leap_year(year);

    if (is_valid_date(year, month, day)) {
        next_day = day + 1;
        next_month = month;
        next_year = year;

        if (month == 2 && is_leap_years) {
            if (next_day > 29) {
                next_day = 1;
                next_month = month + 1;
            }
        }
        else if (month == 2 && !is_leap_years) {
            if (next_day > 28) {
                next_day = 1;
                next_month = month + 1;
            }
        }
        else if ((month == 4 || month == 6 || month == 9 || month == 11) && next_day > 30) {
            next_day = 1;
            next_month = month + 1;
        }
        else if (next_day > 31) {
            next_day = 1;
            if (month == 12) {
                next_month = 1;
                next_year = year + 1;
            }
            else {
                next_month = month + 1;
            }
        }
    }
}

int main() {
    int year, month, day;
    int next_year, next_month, next_day;

    cout << "请输入四位数的年份、月份、以及日:" << endl;
    cin >> year >> month >> day;

    if (year < 1000 || year > 9999) {
        cout << "输入的年份不符合要求" << endl;
        if (month < 1 || month > 12) {
            cout << "输入的月份不符合要求" << endl;
            if (!is_valid_date(year, month, day)) {
                cout << "输入的日期不符合要求" << endl;
            }
        }
    }
    else if (month < 1 || month > 12) {
        cout << "输入的月份不符合要求" << endl;
        if (!is_valid_date(year, month, day)) {
            cout << "输入的日期不符合要求" << endl;
        }
    }
    else if (!is_valid_date(year, month, day)) {
        cout << "输入的日期不符合要求" << endl;
    }
    else {
        get_next_date(year, month, day, next_year, next_month, next_day);
        cout << "下一个日期是：" << next_year << "年 " << next_month << "月 " << next_day << "日" << endl;
    }

    return 0;
}

```

 - **等价类划分**

| 输入条件| 有效等价类 | 编号| 无效等价类|编号|
| ---- |------|-----|-----|-----|
|日期   |1<=日期<=27    |D1|日期<1|D12|
|       |日期=28|        D2|日期>31|D13|
| |       日期=29|        D3|日期=29|D14|
| |       日期=30|        D4|日期=30|D15|
| |       日期=31|        D5|日期=31|D16|
|月份|   月份=4,6,8,11|  M6|月份<1|M17|
| |       月份=1,3,5,7,8,10| M7|月份>12|M18|
| |       月份=2|         M8|
| |       月份=12|        M9|
|年份|   1000<=年份<=9999的闰年|Y10|年份<1000|Y19|
|    |   1000<=年份<=9999的非闰年|Y11|年份>9999|Y20|

- 设计测试用例：

| 年       |月   | 日|   预期输出  |覆盖的有效等价类|覆盖的无效等价类|
|-------|-------|-------|-------   |-------          |-------|
|2000|       4|    1|     2000-4-2 |D1,M6 Y10|
|2000|       2|   28|     2000-2-29|D2,M8,Y10|
|2000|       2|   29|     2000-3-1 |D3,M8,Y10|
|2001|       6|   30|     2000-7-1 |D4,M6,Y11|
|2001|       1|   31|     2000-2-1 |D5,M7,Y11 |
|2000|       12|   1|     2000-12-2|D1,M9,Y10|
|||
|2001|       3|    0|     错误日期 |M7,Y11|D12|
|2001|       5|   32|      错误日期|M7,Y11|         D13 |
|2001|       2|   29|      错误日期|M8,Y11|           D14 |
|2002|       2|   30|      错误日期|M8,Y11|           D15  |
|2003|       4|    31|     错误日期 |M6,Y11|           D16 |
|||
|2000|       0|    1|      错误月份|D1,Y10|             M17|
|2001|       13|   28|     错误月份|D2，Y11|            M18|
|||
|999|        1|     2|     错误年份|D1,M7,|             Y19|
|10000|      2|     2|     错误年份|D1,M8|              Y20|
|666|        0|     0|     错误年份、月份、日期| |      D12,M17,Y19|


### 题目四：找零钱最佳组合

假设商店货品价格(R) 皆不大于 100 元（且为整数） ，若顾客付款在 100 元内(P) ， 求找给顾客最少货币个（张）数？（货币面值 50 元 10 元， 5 元， 1 元四种 ）