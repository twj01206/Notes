# 一、实验目的

**题目一：电话号码问题**

1. 理解等价类划分的概念；

2. 能够根据规格说明设计出符合等价类划分的测试用例；

3. 能够应用等价类划分测试法设计出有效的测试方案。

4. 能熟练应用黑盒测试技术进行测试用例设计；

5. 对测试用例进行优化设计；

**题目二：三角形问题**

1. 理解等价类划分的概念；

2. 能够根据规格说明设计出符合等价类划分的测试用例；

3. 能够应用等价类划分测试法设计出有效的测试方案。

4. 能熟练应用黑盒测试技术进行测试用例设计；

5. 对测试用例进行优化设计；

**题目三：日期问题**

1. 理解等价类划分的概念；

2. 能够根据规格说明设计出符合等价类划分的测试用例；

3. 能够应用等价类划分测试法设计出有效的测试方案

4. 能熟练应用黑盒测试技术进行测试用例设计；

5. 对测试用例进行优化设计

**题目四：找零钱最佳组合**

1. 理解等价类划分的概念；

2. 能够根据规格说明设计出符合等价类划分的测试用例；

3. 能够应用等价类划分测试法设计出有效的测试方案

4. 能熟练应用黑盒测试技术进行测试用例设计；

5. 对测试用例进行优化设计

# 二、实验原理
- 黑盒测试：称为功能测试或数据驱动测试。在测试时，把被测程序视为一个不能打开的黑盒子，在完全不考虑内部特性的情况下进行。
- 采用黑盒测试的目的主要是在己知软件产品所应具有的功能的基础上，进行：
	1. 检查程序功能能否按需求规格说明书的规定正常使思，测试各个功能是否有道漏，检测性能等特性要求是否满足。
	2. 检测人机交互是否错识，检测数据绪构或外部数据库访问是否销误，程序是否能适当地接收输入数据而产生正确的输出结果，并保持外部信息（如数据库或文件）的完整性。
	3. 检测程序初始化和终止方面的错识
- 常见的黑盒测试方法有等价类划分法、边界值法、因果图法、决策表法。

### 等价类测试
- 等价类划分法是一种重要 的、典型的黑盒测试方法，它将不能穷举的测试过程进行合理分类，从而保证设计出来的测试用例具有完整性和代表性。
- 等价类划分法是把所有可能的输入数据，即程序的输入域划分成若干互不相交的子集，称为等价类。
- 所有子集的并集则构成整个输入域。然后从每一个子集中选取少数有代表性的数据作为测试用例。

**等价类的划分有两种不同的情况：**

1. 有效等价类：是指对于程序的规格说明来说，是合理的，有意义的输入数据构成的集合。
2.  无效等价类： 是指对于程序的规格说明来说，是不合理的， 无意义的输入数据构成的集合。在设计测试用例时，要同时考虑有效等价类和无效等价类的设计。
**用等价类划分法设计测试用例步骤：**
1. 形成等价类表，每一等价类规定一个唯一的编号；
2. 设计一个新的测试用例，使其尽可能多地覆盖尚未覆盖的有效等价类，重复这一步骤，直到所有有效等价类均被测试用例所覆盖；
3. 设计一个新测试用例，使其只覆盖一个无效等价类，重复这一步骤直到所有无效等价类均被覆盖。

### 边界值测试
总述:边界值测试是一种测试方法，它专注于测试输入数据的边界值，例如输入的最小值、最大值和临界值。在该方法中，测试人员会针对各种边界条件设计测试用例，从而揭示程序在边界条件下的错误。
**标准边界值测试** 考虑数据范围内的边界值
- 使用在最小值(Min)、略高于最小值(Min+)、正常值(Normal)、略低于最大值(Max-)和最大值处(Max)取输入变量值。
**健壮边界值测试** 考虑有效和无效数据范围内的边界值
- 略低于最小值(Min-)最小值(Min)、略高于最小值(Min+)、正常值(Normal)、略低于最大值(Max-)和最大值处(Max)取输入变量值，略高于最大值(Max+)
### 基于决策表的测试
决策表适合描述不同条件集合下采取行动的若干组合的情况。使用决策表标识测试用例，则把条件解释为输入，行动解释为输出。有时条件最终引用输入的等价类，行为引用被测试软件的主要功能处理部分，规则解释为测试用例。
对于有限条目决策表，如果有 n 个条件， 则必须有 2 条规则。 如果不关心条目实际地表明条件是不相关的，则没有不关心条目的规则统计为 1 条规则， 规则中每出现一个不关心条目，该规则数乘一次 2。

# 三、实验步骤
### **题目一：电话号码问题**
某城市电话号码由三部分组成。它们的名称和内容分别是： 地区码：空白或三位数字；前 缀非'0'或'1'的三位数字；后 缀：4 位数字。假定被测程序能接受一切符合上述规定的电话号码，拒绝所有不符合规定的电话号码。根据该程序的规格说明，作等价类的划分，并设计测试方案。

- **被测程序：**
```
#include <iostream>
#include <regex>
#include <string>
using namespace std;
bool ValidatePhoneNumber(const string& phoneNumber) {
    regex re(R"(^(\d{3}[- ]?)?[2-9]{3}\d{4}$)");
    return regex_match(phoneNumber, re);
}
```

- **等价类划分**：

| 输入条件    | 有效等价类    | 编号    | 无效等价类   | 编号    |
|-------|-------|-------|-------|-------|
| 是否构成电话号码 | 地区码空白或三位数字 |1 | 地区码不空白且非三位数字 | 5|
|  | 前缀非'0'或'1'| 2|  前缀为'0'或'1' | 6 |
|  | 前缀为三位数 | 3 | 前缀不为三位数 | 7 |
|  | 后缀为4位数的电话号码 | 4 | 后缀不为4位数的电话号码 | 8 |

- **设计测试用例：**

| 输入| 预期结果 | 覆盖范围 |
|-------|-------|-------|
| 1234567890 | true | 1、2、3、4 |
| 123-4567890| true| 1、2、3、4|
| 4567890 | true| 1、2、3、4|
| 12-34567890 | false|5 |
| 34567890|false |5 |
| 0345678 |false |4、6 |
| 123457890 |false |4、7 |
| 457890 | false| 4、7|
| 12345678 |flase |1、2、3、8 |
| 45678 |false | 2、3、8|

- **测试程序**

```
#include <iostream>
#include <regex>
#include <vector>
#include <string>
using namespace std;

struct Testcase {
    string input;
    bool expectedResult;
};

vector<Testcase> testcases = {
    {"1234567890", true},
    {"123-4567890", true},
    {"4567890", true},
    {"12-34567890", false},
    {"34567890", false},
    {"0345678", false},
    {"123457890", false},
    {"457890", false},
    {"12345678", false},
    {"45678", false}
};

bool ValidatePhoneNumber(const std::string& phoneNumber) {
    regex re(R"(^(\d{3}[- ]?)?[2-9]{3}\d{4}$)");
    return regex_match(phoneNumber, re);
}

void runTestcases() {
    for (const auto& testcase : testcases) {
        bool result = ValidatePhoneNumber(testcase.input);
        if(result==true) cout << "Test case passed: " << testcase.input << endl;
        if(result==false)  cout << "Test case failed: " << testcase.input << endl;    
    }
}

int main() {
    runTestcases();
    return 0;
}

```

### 题目二：三角形问题
根据下面给出的规格说明，利用等价类划分的方法，给出足够的测试用例。
“一个程序读入三个整数。把此三个数值看成是一个三角形的三个边。这个程序要打印出信息，说明这个三角形是三边不等的、是等腰的、还是等边的。

* **被测程序**
```
string checkTriangleType(int a, int b, int c) {
    if (a + b <= c || a + c <= b || b + c <= a) {
        return "不能构成三角形";
    }
    else if (a == b && b == c) {
        return "构成等边三角形";
    }
    else if (a * a + b * b == c * c || b * b + c * c == a * a || a * a + c * c == b * b) {
        if (a == b || b == c || c == a) {
            return "构成等腰直角三角形";
        }
        else {
            return "构成直角三角形";
        }
    }
    else if (a == b || b == c || c == a) {
        return "构成等腰三角形";
    }
    else {
        return "构成普通三角形";
    }
}


```

 - **等价类划分**
 
| 输入条件| 有效等价类 | 编号 |无效等价类|编号|
|-------   |-------    |-------|------  |-------|
|输入三个正整数|a>0          |1|       a<=0|    7|
||          b>0          |2|       b<=0|     8|
||          c>0|          3|       c<=0|    9|
|构成三角形|          a+b>c|          4|       a+b<=c|    10|
||          a+c>b|          5|       a+c<=b|    11|
||          b+c>a|          6|       b+c<=a|    12|
|构成等腰三角形|          a等于b|          13|     a!=b&&a!=c&&b!=c  |  16|
| |                       a等于c|          14|       ||
| |                       b等于c|          15|       ||
|构成等边三角形|a等于b&&b等于c&&a等于c|17|a!=b|20|
||             |                     |   b!=c|21||
||             |                     |   a!=c|22||

- **设计测试用例**

| 输入(a、b、c) | 预期结果 | 覆盖范围 | 
|-----|-----|-----| 
| 4、5、6        |其他三角形 | 1、2、3、4、5、6 |
| 5、5、6        |等腰三角形 | 1、2、3、4、5、6、13 |
| 5、6、5        |等腰三角形 | 1、2、3、4、5、6、14 |
| 6、5、5        |等腰三角形 | 1、2、3、4、5、6、15 |
| 6、6、6        |等腰三角形 | 1、2、3、4、5、6、13、14、15、17 |
| 1、5、6        |false | 2、3、10 |
| 1、6、5        |false | 2、3、11 |
| 6、1、5        |false | 2、3、12 |
| 1、2、5        |false | 2、3、20、21、22|

- **测试程序**
```
#include <iostream>
#include <vector>
using namespace std;

struct Testcase {
    int a;
    int b;
    int c;
    string expectedResult;
};

string checkTriangleType(int a, int b, int c) {
    if (a + b <= c || a + c <= b || b + c <= a) {
        return "不能构成三角形";
    }
    else if (a == b && b == c) {
        return "构成等边三角形";
    }
    else if (a * a + b * b == c * c || b * b + c * c == a * a || a * a + c * c == b * b) {
        if (a == b || b == c || c == a) {
            return "构成等腰直角三角形";
        }
        else {
            return "构成直角三角形";
        }
    }
    else if (a == b || b == c || c == a) {
        return "构成等腰三角形";
    }
    else {
        return "构成普通三角形";
    }
}

int main() {
    vector<Testcase> testcases = {
        {4, 5, 6, "其他三角形"},
        {5, 5, 6, "等腰三角形"},
        {5, 6, 5, "等腰三角形"},
        {6, 5, 5, "等腰三角形"},
        {6, 6, 6, "等腰三角形"},
        {1, 5, 6, "不构成三角形"},
        {1, 6, 5, "不构成三角形"},
        {6, 1, 5, "不构成三角形"},
        {1, 2, 5, "不构成三角形"}
    };

    for (const auto& testcase : testcases) {
        int a = testcase.a;
        int b = testcase.b;
        int c = testcase.c;

        string expectedType = checkTriangleType(a, b, c);

        cout << "输入: " << a << ", " << b << ", " << c << endl;
        cout << "实际结果: " << expectedType << endl;
        cout << "期望结果: " << testcase.expectedResult << endl;
        cout << endl;
    }

    return 0;
}

```


### 题目三：日期问题

用决策表测试法测试以下程序:该程序有三个输入变量 month、day、year（month 、day 和 year 均为整数值，并且满足： 1≤month≤12 和 1≤day≤31 分), 别作为输入日期的月份、日、年份，通过程序可以输出该输入日期在日历上隔一天的日期。例如，输入为 2004年 11 月 29 日,则该程序的输出为 2004 年 12 月 1 日。

- **被测程序**
```
bool isLeapYear(int year) {
    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
}

string formatDate(int year, int month, int day) {
    if (year < 1 || year > 9999) {
        return "错误年份";
        if (month < 1 || month > 12) {
            return "错误月份";
            if (day < 1 || day > 31) {
                return "错误日期";
            }
        }
    }
    if (month < 1 || month > 12) {
        return "错误月份";
        if (day < 1 || day > 31) {
            return "错误日期";
        }
    }
    if (day < 1 || day > 31) {
        return "错误日期";
    }
    if ((month == 4 || month == 6 || month == 9 || month == 11) && day > 30) {
        return "错误日期";
    }
    if (month == 2) {
        if (isLeapYear(year) && day > 29) {
            return "错误日期";
        }
        if (!isLeapYear(year) && day > 28) {
            return "错误日期";
        }
    }

    return to_string(year) + "-" + to_string(month) + "-" + to_string(day);
}
```

 - **等价类划分**

| 输入条件| 有效等价类 | 编号| 无效等价类|编号|
| ---- |------|-----|-----|-----|
|日期   |1<=日期<=27    |D1|日期<1|D12|
|       |日期=28|        D2|日期>31|D13|
| |       日期=29|        D3|日期=29|D14|
| |       日期=30|        D4|日期=30|D15|
| |       日期=31|        D5|日期=31|D16|
|月份|   月份=4,6,8,11|  M6|月份<1|M17|
| |       月份=1,3,5,7,8,10| M7|月份>12|M18|
| |       月份=2|         M8|
| |       月份=12|        M9|
|年份|   1000<=年份<=9999的闰年|Y10|年份<1000|Y19|
|    |   1000<=年份<=9999的非闰年|Y11|年份>9999|Y20|


- 设计测试用例：

| 年       |月   | 日|   预期输出  |覆盖的有效等价类|覆盖的无效等价类|
|-------|-------|-------|-------   |-------          |-------|
|2000|       4|    1|     2000-4-2 |D1,M6 Y10|
|2000|       2|   28|     2000-2-29|D2,M8,Y10|
|2000|       2|   29|     2000-3-1 |D3,M8,Y10|
|2001|       6|   30|     2000-7-1 |D4,M6,Y11|
|2001|       1|   31|     2000-2-1 |D5,M7,Y11 |
|2000|       12|   1|     2000-12-2|D1,M9,Y10|
|||
|2001|       3|    0|     错误日期 |M7,Y11|D12|
|2001|       5|   32|      错误日期|M7,Y11|         D13 |
|2001|       2|   29|      错误日期|M8,Y11|           D14 |
|2002|       2|   30|      错误日期|M8,Y11|           D15  |
|2003|       4|    31|     错误日期 |M6,Y11|           D16 |
|||
|2000|       0|    1|      错误月份|D1,Y10|             M17|
|2001|       13|   28|     错误月份|D2，Y11|            M18|
|||
|999|        1|     2|     错误年份|D1,M7,|             Y19|
|10000|      2|     2|     错误年份|D1,M8|              Y20|
|0|        0|     0|     错误年份、月份、日期| |      D12,M17,Y19|

**列出动作桩**

- 动作列表

| 动作名称|动作编号|动作项|
|-------|-------|-------|
|本月的日期下一天|D|日期+1|
|下月的第一天|M|月份，日期=1|
|下年的第一天|Y|年份，月份=1，日期=1|
|其他|        E|error|

- 动作桩

|规则    |规则编号 |年份|    月份|       日期|   动作编号|
|-------|-------|-------|-------|--------|-------|
|1-27号  |R1     |Y10、Y11|  M6、M7、M8、M9 |  D1 | D|
|闰年2月28号|R2     |Y10   |  M8|            D2|       D|
|闰年2月29号| R3|     Y10|      M8|            D3|      M|
|非闰年2月28号|R4|     Y11|M8|               D2|M|
|非闰年2月29号|R5|Y11|M8|D3|E|
|小月末尾| R6|     Y10、Y11|M6|D4|M|
|大月30号|R7|Y10、Y11|M7|D4|                          D|
|大月(不包含12月)末尾|R8|      Y10、Y11|M7|D5|M|
|年底|                R9| Y10、Y11|M9|D5|Y|
|其他(不符合要求的)|R10 |        |  |  |E|

- 决策表

| 规则|动作|
|-------|-------|
|R1、R2、R7|  D|
|R3、R4、R6、R8|M|
|R9|Y|
|R5、R10|E|



### 题目四：找零钱最佳组合

假设商店货品价格(R) 皆不大于 100 元（且为整数） ，若顾客付款在 100 元内(P) ， 求找给顾客最少货币个（张）数？（货币面值 50 元 10 元， 5 元， 1 元四种 ）

**- 被测程序**
```
int minnumberCoins(int price, int payment) {
	if (payment < price || payment < 0 || price < 0) {
		return -1;
	}
	vector<int> coins = { 1,5,10,50 };//货币面值
	int n = coins.size();

	vector<int> dp(payment + 1,INT_MAX);
	dp[0] = 0;

	for (int i = 1; i <= payment; i++) {
		for (int j = 0; i < n; j++) {
			if (coins[j] <= i) {
				int sub = dp[i - coins[j]];
				if (sub != INT_MAX) {
					dp[i] = min(dp[i], sub + 1);
				}
			}
		}
	}
	int change = payment - price;
	return dp[change];
}
```
- **划分等价类**

|输入条件|有效等价类|编号|无效等价类|编号|
|-------       |-------|-------|-------|-------|
|商品价格|  R>0 |1|R<0|7|
|        |R=0   |2|R>100|8|
||        R<100 | 3|||
||        R=100|  4||
|付款|    P>R|5|P<R|9|
|       | P=R|6|

- **设计测试用例**

| 商品价格|付款 |预期输出|有效等价类覆盖范围|无效等价类覆盖范围|
|-------|-------|-------|-------|-------|
|0      |0      |   0|        2、6|
|50|      50|       1|       3、6|
|67|      70|       3|       3、5| 
|100|     100|      2|       4、6|
|-1|        1|      -1|       5|                   7|
|101|       100|    -1|      |                    8、9|
|60|     50|      -1|        3|                   9|  



# 实验结果

### **题目一：电话号码问题**

![[实验一号码.png]]

### 题目二：三角形问题

![[实验二.png]]

### 题目三：日期问题

![[实验二 1.png]]

### 题目四：找零钱问题


# 五、讨论分析
### 实验一（电话号码问题）：

在等价类划分方法的基础上，可以通过设计有效的测试用例对电话号码问题进行测试。测试时候需要考虑到各种因素，比如：有效等价类、无效等价类、边界值（标准边界值和健壮边界值）等因素。在实验中，使用测试用例测试结果正确，说明本次实验使用该方法时有效的。如果测试用例不通过，需要重新考虑等价类的划分是否正确，以及测试用例的设计是否合理等，不断进行测试找出错误，最终可以进行有效的测试。

### 实验二（三角形问题）：

在等价类划分方法的基础上，可以通过设计有效的测试用例对电话号码问题进行测试。测试时候需要考虑到各种因素，比如：有效等价类、无效等价类、边界值（标准边界值和健壮边界值）等因素。在实验中，使用测试用例测试结果正确，说明本次实验使用该方法时有效的。如果测试用例不通过，需要重新考虑等价类的划分是否正确，以及测试用例的设计是否合理等，不断进行测试找出错误，最终可以进行有效的测试。

### 实验三（日期问题）：

在决策表测试法的基础上，可以通过设计有效的测试用例对电话号码问题进行测试。测试时候需要考虑到各种因素，比如：决策的路径问题和条件符合问题等因素。在实验中，使用测试用例测试结果正确，说明本次实验使用该方法时有效的。如果测试用例不通过，需要重新考虑等决策的设计和条件是否正确使用，以及测试用例的设计是否合理等，不断进行测试找出错误，最终可以进行有效的测试。

### 实验四（找零钱最佳组合）：

在动态规划算法、等价划分法和边界值分析法的基础上，可以通过设计有效的测试用例对找零钱最佳组合问题进行测试。测试时候需要考虑到各种因素，比如：有效等价类、无效等价类、边界值（标准边界值和健壮边界值）等因素。在实验中，使用测试用例测试结果正确，说明本次实验使用该方法时有效的。如果测试用例不通过，需要重新考虑动态规划算法是否存在问题，逻辑是否存在错误，（一般最为明显的错误是边界值的选取）或者等价类的划分是否正确，以及测试用例的设计是否合理等，不断进行测试并根据实际情况修改算法，切实符合实际需求的时间复杂度等找出错误，最终可以进行有效的测试。